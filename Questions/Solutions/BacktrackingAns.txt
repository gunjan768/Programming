https://www.geeksforgeeks.org/samsung-interview-experience-set-28-campus/

// Top Down Approach.

#include<bits/stdc++.h>
using namespace std;
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
using namespace __gnu_pbds;
template <typename T>  using ordered_set =
tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
#define ll           long long
#define rep(i,j,n)   for(int i=j;i<n;i++)
#define scn(a)       scanf("%d",&a)
#define scns(a,b)    scanf("%d %d",&a,&b)
#define print(a)     printf("%d\n",a)
#define vec          vector<int>
#define pb           push_back    
#define pairs        pair<int,int>
#define f            first
#define s            second
#define all(v)       v.begin(),v.end()
#define mem(a,b)     memset(a,b,sizeof(a))
#define inf          INT_MAX
const int mod=1e9+7;
const int N=60+5;
int t;

int n,ans;
string s1[N];

void solve(int i,int pos,int coin,int bomb)
{
    if(i==-1 || pos<0 || pos>5)
    {
        ans=max(ans,coin);
      
        return;
    }
    
    if(s1[i][pos]=='2' && bomb==0)
    {
        ans=max(ans,coin);

        return;
    }

    int newCoin=coin;

    if(s1[i][pos]=='1')
    newCoin++;

    solve(i-1,pos,newCoin,bomb);
    solve(i-1,pos-1,newCoin,bomb);
    solve(i-1,pos+1,newCoin,bomb);

    solve(i-1,pos,newCoin,1);
    solve(i-1,pos-1,newCoin,1);
    solve(i-1,pos+1,newCoin,1);
}

int main()
{
    scn(t);

    while(t--)
    {
        scn(n);

        rep(i,0,n)
        cin>>s1[i];

        solve(n-2,2,0,0); 
        solve(n-2,1,0,0);
        solve(n-2,3,0,0);

        print(ans); ans=0;
    }
}

sample Input : 
1
7
01020
02221
02111
10100
00122
11001
xxSxx  

// Bottom Up approach using DP.

#include<bits/stdc++.h>
using namespace std;
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
using namespace __gnu_pbds;
template <typename T>  using ordered_set =
tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
#define ll           long long
#define rep(i,j,n)   for(int i=j;i<n;i++)
#define scn(a)       scanf("%d",&a)
#define scns(a,b)    scanf("%d %d",&a,&b)
#define print(a)     printf("%d\n",a)
#define vec          vector<int>
#define pb           push_back    
#define pairs        pair<int,int>
#define f            first
#define s            second
#define all(v)       v.begin(),v.end()
#define mem(a,b)     memset(a,b,sizeof(a))
#define inf          INT_MAX
const int mod=1e9+7;
const int N=60+5;
int t;

int n,dp[N][N][6];
string s1[N];

int check(int bomb,int flag)
{
    if(flag==0)
    return 0;

    if(flag==-1 || bomb==5)
    return -1;

    return bomb+1;
}

int solve(int i,int pos,int bomb,int flag)
{
    if(i==-1 || (s1[i][pos]=='2' && bomb==0))
    return 0;
    
    if(dp[i][pos][bomb] != -1)
    return dp[i][pos][bomb];

    int coin=0,newFlag=0,newBomb,res=check(bomb,flag);

    if(res==0)
    newBomb=0,newFlag=0;
    else if(res==-1)
    newBomb=0,newFlag=-1;
    else
    newBomb=res,newFlag=1;

    coin=(s1[i][pos]=='1'? 1 : 0)+solve(i-1,pos,newBomb,newFlag);

    if(pos!=1)
    coin=max(coin,(s1[i][pos-1]=='1'? 1 : 0) + solve(i-1,pos-1,newBomb,newFlag));

    if(pos!=3)
    coin=max(coin,(s1[i][pos+1]=='1'? 1 : 0) + solve(i-1,pos+1,newBomb,newFlag));

    if(flag==0)
    newFlag=1;

    if(newFlag==1)
    {
        coin=max(coin,(s1[i][pos]=='1'? 1 : 0) + solve(i-1,pos,bomb+1,newFlag));

        if(pos!=1)
        coin=max(coin,(s1[i][pos-1]=='1'? 1 : 0) + solve(i-1,pos-1,bomb+1,newFlag));

        if(pos!=3)
        coin=max(coin,(s1[i][pos+1]=='1'? 1 : 0) + solve(i-1,pos+1,bomb+1,newFlag));
    }
    
    return dp[i][coin][bomb]=coin;
}

int main()
{
    scn(t);

    while(t--)
    {
        scn(n);

        rep(i,0,n)
        cin>>s1[i];

        mem(dp,-1);

        int ans=solve(n-2,2,0,0);

        print(ans);
    }
}